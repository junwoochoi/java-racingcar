# WIL

스터디를 진행하면서 새롭게 깨닫거나, 중요성을 느낀 부분들을 정리한다.





- `.forEach`함수 보다는 `for-each` 가 대부분의 상황에서 더 낫다.
    - 찬구 담당님이 달아주셨던 [링크](https://homoefficio.github.io/2016/06/26/for-loop-%EB%A5%BC-Stream-forEach-%EB%A1%9C-%EB%B0%94%EA%BE%B8%EC%A7%80-%EB%A7%90%EC%95%84%EC%95%BC-%ED%95%A0-3%EA%B0%80%EC%A7%80-%EC%9D%B4%EC%9C%A0/)
- 비즈니스 로직과 뷰 로직을 분리하기는 생각보다 어려웠다... 하지만 이 부분을 신경쓰지 않으면 요구사항 변경에 취약한 구조가 나온다.
    - 로직을 분리하면서 `getter`를 사용안하려는데 집착하다보니 분리한 것도 아니고, 안한 것도 아닌 애매한 코드가 나오게 되었다. 최종적으로는 `DTO` 클래스에 대해서는 `getter`를 사용하되 다른 클래스에서는 사용을 지양하는 방향이 되었다.
- `Mockito`를 사용하면서 대부분 `when()`,`thenReturn()` 메소드를 사용했는데, `given()`,`then()`메소드를 사용하는 것이 더 알맞다.
    - 찬구 담당님이 달아주셨던 [링크](https://mskwon25.github.io/tdd/MockitoBBD/)
- 매직 넘버, 매직값은 모두 상수로 관리하자. 가독성이 훨씬 좋아진다.
    - 스터디를 시작하고 나서, 스터디 하기 전에 내가 짠 코드를 보니 매직넘버가 너무 많았다.... 앞으로는 최대한 따로 빼서 가독성도 높이고, 수정시에도 더 용이하도록 하자.
- 테스트를 먼저 짜고, 시작하면, 초기에는 테스트를 짜느라 개발이 오래걸리는 것 같다. 하지만 실제로 해보니 전반적인 코드 수정시에 테스트 코드를 믿고, 바로 바로 수정한 코드의 동작에 대한 피드백을 받을 수 있어서 생산성이 좋아진 느낌이 들었다.
- 파라미터들은 반드시 검증을 하자. 스프링의 경우 `Assertions`를 이용할 수 있고, `racingcar`에서는 `validate` 메소드를 따로 구현하거나 `assert`를 사용하여서 검증하였다.
- `List` 혹은 `Collection` , `객체`를 리턴하거나 파라미터로 넘겨줄 때, 주의하자. 자바는 기본적으로 `call by value`이지만 해당 객체가 가지고 있는 필드들의 주소값이 넘겨지면서, 넘겨진 객체 내부에 필드나 엘레먼트가 의도치않게 변경될 수 있다.
    - 메소드의 응답으로 내부의 private필드를 넘겨줄 때는 `new ArrayList(privateList)` 와 같이 넘겨줬다.
- 일급 콜렉션을 적용하면 좀 더 객체지향적인 코드를 작성할 수 있다. 
    - 불변 보장, 상태와 행위를 한 곳에서 관리, 의미 부여 가능 등의 장점
    - 이동욱님의 [일급 콜렉션의 소개와 써야할 이유](https://jojoldu.tistory.com/412)
- 부수효과를 포함하는 함수와 그렇지 않은 함수를 구분하여 사용하자. (*명령-쿼리 분리원칙*)
    - `오브젝트` 202쪽에 자세한 내용이 나온다.
    - 기본적으로 다음 두가지 원칙을 준수해야한다.
        1. 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
        2. 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.
    - `쿼리`가 부수효과를 가져서 내부의 정보를 변경하면, 외부에서 사용하는 입장에서는 어떠한 결과를 낳을 지 알 수 없다. 결과적으로 명령과 쿼리를 뒤섞어 사용하면 실행 결과를 예측하기 어렵고, 잘못 사용되기 쉬우며 버그를 양산하게 된다.
    

- 축약어 사용을 지양하자.  나한테는 나중에 봤을 때 이해될 수 있어도, 그게 다른 사람이 보기에도 이해하기 쉬우리란 법은 없다.
- 책임을 중심으로 생각하자. 아무 생각없이 코딩하다가 내 코드를 다시 읽었을 때, 한 객체가 너무 많은 책임을 가지고 있는 상황이 너무 잦다. 
  - 이런 경우 테스트를 잘 작성하고, 책임을 분리하면서 다시 테스트를 돌려보면서 리팩토링하면 좋은 결과가 나왔던 것 같다.
  - 인텔리제이의 리팩토링 기능을 잘 사용하자. [백명석님의 refactoring 강좌](https://www.youtube.com/watch?v=3MTf43_RcVM) 이 외에도 해당 채널에 좋은 내용의 동영상이 많아서, 시간될 때, 꼭 봐야겠다.
- 추상화는 항상 좋은 것은 아니다. 추상화로 인해 지나친 복잡성을 갖지 않도록 조심하자.
- 불변한 객체는 가능하면 final 로 선언하자. Kotlin 처럼 편리하게 됐으면 좋겠지만... 자바에서는 습관이 되지않아서인지 쉽지 않다. 그래도 신경써서 불변성을 보장해주는 것이 좋다.
- [옵저버 패턴]([https://flowarc.tistory.com/entry/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4Observer-Pattern](https://flowarc.tistory.com/entry/디자인-패턴-옵저버-패턴Observer-Pattern)) 을 사용하면 조금 더 편리하게 비즈니스 로직과 UI 관련된 부분을 분리할 수 있다.
  - 스프링에서는 `ApplicationEvent` 를 편리하게 사용할 수 있으니, 실무에서도 적용할 부분이 있다면, 시도해보면 복잡한 의존성을 적절히 끊어줄 수 있을 것 같다.
  - [우아한 객체지향](https://www.youtube.com/watch?v=dJ5C4qRqAgA) 발표에서도 이벤트를 활용해 의존성을 끊어주는 부분이 나온다. 아직 저정도로 복잡한 서비스를 만들어 볼 일은 없었지만, 알아두자.
- DTO 와 VO를 구분하여 사용하자.
  - [관련 영상 링크](https://www.youtube.com/watch?v=EeJnNaiMy3U)
- 다양한 Stream 관련 메소드들을 배웠다. Stream 은 편리하지만 때때로는 성능에 문제를 가져오거나, 가독성을 해칠 수 있으니 항상 신경쓰며 사용해야겠다.
- `Optional`에서 `orElse(getDefaultName())`와 같은 식으로 `orElse()`안에 파라미터로 함수가 들어갈  경우 , 해당 객체가 존재하더라도 항상 `getDefaultName()` 이 호출된다. 이를 방지하기위해서는 `.orElseGet(() -> getDefaultName())`과 같이 호출하는 것이 적절하다!
  - [관련 링크](https://www.baeldung.com/java-optional-or-else-vs-or-else-get)







---

